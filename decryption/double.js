let secret1 = [
  0xBB1C, 0xEA1F, 0xF0C1, 0x1FEB, 0x2409, 0x79E1, 0xF578, 0xBA6F,
  0xE32C, 0x2E7F, 0x76F0, 0x9703, 0xE1D6, 0x4036, 0xF2BF, 0x1B13,
  0x75FD, 0xDA9, 0xD5AD, 0x935E, 0xC6F2, 0x7E65, 0x7AC5, 0x1853,
  0xCD3C, 0x9E2, 0x7E31, 0x3AC4, 0xB3FE, 0x2979, 0x86B7, 0x982F,
  0x9F66, 0xF369, 0xDC9D, 0xA01B, 0xCCFB, 0x41CC, 0x6DA6, 0x79F5,
  0xB5B3, 0xA1D4, 0x4EDA, 0x4F73, 0xCB42, 0x70AE, 0xCFBF, 0x6295
];
let secretGetBinary = (p => (secret1[p / 16 >>> 0] >>> (p % 16)) & 0x1)

let secret2 = [
  0x20, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11,
  12, 13, 12, 13, 14, 15, 0x10, 0x11, 0x10, 0x11, 0x12, 0x13, 20, 0x15, 20, 0x15,
  0x16, 0x17, 0x18, 0x19, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1c, 0x1d, 30, 0x1f, 0x20, 1
];

let secret3 = [
  0x10, 7, 20, 0x15, 0x1d, 12, 0x1c, 0x11, 1, 15, 0x17, 0x1a, 5, 0x12, 0x1f, 10,
  2, 8, 0x18, 14, 0x20, 0x1b, 3, 9, 0x13, 13, 30, 6, 0x16, 11, 4, 0x19
];

let secretArrays = [
  [
    0x10101, 0x100, 0x1000101, 0x1000000, 0x10000, 0x1010101, 0x1010001, 0x1, 0x1010000, 0x10001, 0x10100, 0x101, 0x1000100, 0x1000001, 0x0, 0x1010100,
    0x0, 0x1010101, 0x1010100, 0x100, 0x10101, 0x10000, 0x1000101, 0x1000000, 0x10001, 0x10100, 0x101, 0x1010001, 0x1000001, 0x1000100, 0x1010000, 0x1,
    0x100, 0x1000000, 0x10101, 0x1, 0x1000101, 0x10100, 0x10000, 0x1010001, 0x1010101, 0x101, 0x1000001, 0x1010100, 0x1010000, 0x10001, 0x1000100, 0x0,
    0x1010101, 0x101, 0x1, 0x10000, 0x100, 0x1000001, 0x1000000, 0x1010100, 0x1000100, 0x1010001, 0x1010000, 0x10101, 0x10001, 0x0, 0x10100, 0x1000101
  ], [
    0x1010101, 0x1000000, 0x1, 0x10101, 0x10100, 0x1010001, 0x1010000, 0x100, 0x1000001, 0x1010100, 0x10000, 0x1000101, 0x101, 0x0, 0x1000100, 0x10001,
    0x1010000, 0x1000101, 0x100, 0x1010100, 0x1010101, 0x10000, 0x1, 0x10101, 0x101, 0x0, 0x1000000, 0x10001, 0x10100, 0x1000001, 0x1010001, 0x1000100,
    0x0, 0x10101, 0x1010100, 0x1010001, 0x10001, 0x100, 0x1000101, 0x1000000, 0x1000100, 0x1, 0x101, 0x10100, 0x1000001, 0x1010000, 0x10000, 0x1010101,
    0x1000101, 0x1, 0x10001, 0x1000000, 0x1010000, 0x1010101, 0x100, 0x10000, 0x1010001, 0x10100, 0x1010100, 0x101, 0x0, 0x1000100, 0x10101, 0x1000001
  ], [
    0x10001, 0x0, 0x1000001, 0x10101, 0x10100, 0x1010000, 0x1010101, 0x1000100, 0x1000000, 0x1000101, 0x101, 0x1010100, 0x1010001, 0x100, 0x10000, 0x1,
    0x1000101, 0x1010100, 0x0, 0x1000001, 0x1010000, 0x100, 0x10100, 0x10001, 0x10000, 0x1, 0x1000100, 0x10101, 0x101, 0x1010001, 0x1010101, 0x1000000,
    0x1000101, 0x10100, 0x100, 0x1000001, 0x1, 0x1010101, 0x1010000, 0x0, 0x1010001, 0x1000000, 0x10000, 0x101, 0x1000100, 0x10001, 0x10101, 0x1010100,
    0x1000000, 0x10001, 0x1000101, 0x0, 0x10100, 0x1000001, 0x1, 0x1010100, 0x100, 0x1010101, 0x10101, 0x1010000, 0x1010001, 0x1000100, 0x10000, 0x101
  ], [
    0x1010100, 0x1000101, 0x10101, 0x1010000, 0x0, 0x10100, 0x1000001, 0x10001, 0x1000000, 0x10000, 0x1, 0x1000100, 0x1010001, 0x101, 0x100, 0x1010101,
    0x1000101, 0x1, 0x1010001, 0x1000100, 0x10100, 0x1010101, 0x0, 0x1010000, 0x100, 0x1010100, 0x10000, 0x101, 0x1000000, 0x10001, 0x10101, 0x1000001,
    0x10001, 0x10100, 0x1000001, 0x0, 0x101, 0x1010001, 0x1010100, 0x1000101, 0x1010101, 0x1000000, 0x1010000, 0x10101, 0x1000100, 0x10000, 0x1, 0x100,
    0x1010000, 0x1010101, 0x0, 0x10100, 0x10001, 0x1000000, 0x1000101, 0x1, 0x1000001, 0x100, 0x1000100, 0x1010001, 0x101, 0x1010100, 0x10000, 0x10101
  ], [
    0x10000, 0x101, 0x100, 0x1000000, 0x1010100, 0x10001, 0x1010001, 0x10100, 0x1, 0x1000100, 0x1010000, 0x1010101, 0x1000101, 0x0, 0x10101, 0x1000001,
    0x10101, 0x1010001, 0x10000, 0x101, 0x100, 0x1010100, 0x1000101, 0x1000000, 0x1000100, 0x0, 0x1010101, 0x10001, 0x1010000, 0x1000001, 0x1, 0x10100,
    0x100, 0x10000, 0x1000000, 0x1010001, 0x10001, 0x1000101, 0x1010100, 0x1, 0x1010101, 0x1000001, 0x101, 0x1000100, 0x10100, 0x1010000, 0x0, 0x10101,
    0x1010001, 0x1, 0x101, 0x1010100, 0x1000000, 0x10101, 0x10000, 0x1000101, 0x10100, 0x1010101, 0x0, 0x1000001, 0x10001, 0x100, 0x1000100, 0x1010000
  ], [
    0x101, 0x1000000, 0x10001, 0x1010101, 0x1000001, 0x10000, 0x10100, 0x1, 0x0, 0x1000101, 0x1010000, 0x100, 0x10101, 0x1010100, 0x1000100, 0x1010001,
    0x10001, 0x1010101, 0x100, 0x10000, 0x1010100, 0x101, 0x1000001, 0x1000100, 0x10100, 0x1000000, 0x1000101, 0x10101, 0x0, 0x1010001, 0x1010000, 0x1,
    0x1000001, 0x10101, 0x1010101, 0x1000100, 0x10000, 0x1, 0x101, 0x1010000, 0x1010100, 0x0, 0x100, 0x10001, 0x1000000, 0x1000101, 0x1010001, 0x10100,
    0x100, 0x1010000, 0x10000, 0x101, 0x1000001, 0x1000100, 0x1010101, 0x10001, 0x1010001, 0x10101, 0x1000000, 0x1010100, 0x10100, 0x0, 0x1, 0x1000101
  ], [
    0x100, 0x1010001, 0x10000, 0x10101, 0x1010101, 0x0, 0x1, 0x1000101, 0x1010000, 0x101, 0x1000001, 0x1010100, 0x1000100, 0x10001, 0x10100, 0x1000000,
    0x1000101, 0x0, 0x1010001, 0x1010100, 0x100, 0x1000001, 0x1000000, 0x10001, 0x10101, 0x1010000, 0x1000100, 0x101, 0x10000, 0x1010101, 0x1, 0x10100,
    0x1000000, 0x100, 0x1010001, 0x1000101, 0x101, 0x1010000, 0x1010100, 0x10101, 0x10001, 0x1010101, 0x10100, 0x1, 0x0, 0x1000100, 0x1000001, 0x10000,
    0x10100, 0x1010001, 0x1000101, 0x1, 0x1000000, 0x100, 0x10001, 0x1010100, 0x1000001, 0x1000100, 0x0, 0x1010101, 0x10101, 0x10000, 0x1010000, 0x101
  ], [
    0x1000101, 0x10000, 0x1, 0x100, 0x10100, 0x1010101, 0x1010001, 0x1000000, 0x10001, 0x1000001, 0x1010000, 0x10101, 0x1000100, 0x0, 0x101, 0x1010100,
    0x1000000, 0x1010101, 0x1000101, 0x1, 0x10001, 0x1010000, 0x1010100, 0x100, 0x101, 0x1000100, 0x10100, 0x1010001, 0x0, 0x10101, 0x1000001, 0x10000,
    0x1010100, 0x1010001, 0x100, 0x1000000, 0x1000001, 0x101, 0x10101, 0x10000, 0x0, 0x10100, 0x10001, 0x1000101, 0x1010101, 0x1010000, 0x1000100, 0x1,
    0x10000, 0x1000000, 0x10101, 0x1010100, 0x100, 0x10001, 0x1, 0x1000101, 0x1010101, 0x101, 0x1000001, 0x0, 0x1010000, 0x1000100, 0x10100, 0x1010001
  ]
];


exports.decode = (buffer, x1, x2, x3) => {
  // first encryption
  let out_buffer = bit_encryption(buffer);

  // second encryption
  let key1 = x1 | 0x0418;
  let key2 = (x2 | 0x8041);
  let key3 = (x3 | 0x1804);

  for (let i = 0; i < out_buffer.length; i++) {
    let data = out_buffer[i];
    let out = data ^ (key1 >> 8);
    key1 = ((data + key1) * key2 + key3) & 0xFFFF;
    out_buffer[i] = out;
  }

  return out_buffer;
}


exports.determine = () => {
  return false; // disabled for now, something doesn't work right! :(
}


function bit_encryption(buffer) {
  let num = (buffer.length - 20 + 7) >> 3;
  let num2 = 0;
  let num3 = 0;

  let tBuffer = Buffer.allocUnsafe(0x40);
  let buffer2 = buffer.slice(20);

  // eslint-disable-next-line no-constant-condition
  while (true) {
    tBuffer.fill(0);
    let d2 = 0;
    let d3 = 8;

    do {
      let num4 = buffer2[num2++];
      tBuffer[d2] = ((num4 >> 7) & 1);
      let index = d2 + 1;
      tBuffer[index++] = ((num4 >> 6) & 1);
      tBuffer[index++] = ((num4 >> 5) & 1);
      tBuffer[index++] = ((num4 >> 4) & 1);
      tBuffer[index++] = ((num4 >> 3) & 1);
      tBuffer[index++] = ((num4 >> 2) & 1);
      tBuffer[index++] = ((num4 >> 1) & 1);
      tBuffer[index] = (num4 & 1);
      d2 = index + 1;
      d3--;
    }
    while (d3 > 0);

    // now we have 64 bit data spreaded each bit as byte in tBuffer
    sub_step(tBuffer);

    // now we should make 64 bit data to 8 byte back
    let d4 = 0;
    let d5;
    do {
      d5 = (tBuffer[d4 + 7] | (2 * (tBuffer[d4 + 6] | (2 * (tBuffer[d4 + 5] | (2 * (tBuffer[d4 + 4] | (2 * (tBuffer[d4 + 3] | (2 * (tBuffer[d4 + 2] | (2 * (tBuffer[d4 + 1] | (2 * tBuffer[d4]))))))))))))));
      d4 += 8;
      buffer2[num3++] = d5;
    }
    while (d4 < 0x40);
    if (num-- == 1) {
      break;
    }
  }


  return buffer2.slice(0, (buffer[16] << 0x18) + (buffer[17] << 0x10) + (buffer[18] << 0x8) + buffer[19]);
}




function sub_step(in_buffer) {
  let d2 = 0xf;
  let numArray = [];
  let buffer = Buffer.alloc(0x30)

  // eslint-disable-next-line no-constant-condition
  while (true) {
    let d3 = 0x0;
    let l2 = true;

    do {
      let t = (secretGetBinary((0x30 * d2) + d3) ^ in_buffer[secret2[d3] + 0x1f]);
      d3++;
      buffer[d3 - 0x1] = t;
      if (d3 >= 0x30) {
        l2 = false;

        numArray[0x0] = secretArrays[0][buffer[0x4] | (0x2 * (buffer[0x3] | (0x2 * (buffer[0x2] | (0x2 * (buffer[0x1] | (0x2 * (buffer[0x5] | (0x2 * buffer[0x0])))))))))];
        numArray[0x1] = secretArrays[1][buffer[0xa] | (0x2 * (buffer[0x9] | (0x2 * (buffer[0x8] | (0x2 * (buffer[0x7] | (0x2 * (buffer[0xb] | (0x2 * buffer[0x6])))))))))];
        numArray[0x2] = secretArrays[2][buffer[0x10] | (0x2 * (buffer[0xf] | (0x2 * (buffer[0xe] | (0x2 * (buffer[0xd] | (0x2 * (buffer[0x11] | (0x2 * buffer[0xc])))))))))];
        numArray[0x3] = secretArrays[3][buffer[0x16] | (0x2 * (buffer[0x15] | (0x2 * (buffer[0x14] | (0x2 * (buffer[0x13] | (0x2 * (buffer[0x17] | (0x2 * buffer[0x12])))))))))];
        numArray[0x4] = secretArrays[4][buffer[0x1c] | (0x2 * (buffer[0x1b] | (0x2 * (buffer[0x1a] | (0x2 * (buffer[0x19] | (0x2 * (buffer[0x1d] | (0x2 * buffer[0x18])))))))))];
        numArray[0x5] = secretArrays[5][buffer[0x22] | (0x2 * (buffer[0x21] | (0x2 * (buffer[0x20] | (0x2 * (buffer[0x1f] | (0x2 * (buffer[0x23] | (0x2 * buffer[0x1e])))))))))];
        numArray[0x6] = secretArrays[6][buffer[0x28] | (0x2 * (buffer[0x27] | (0x2 * (buffer[0x26] | (0x2 * (buffer[0x25] | (0x2 * (buffer[0x29] | (0x2 * buffer[0x24])))))))))];
        numArray[0x7] = secretArrays[7][buffer[0x2e] | (0x2 * (buffer[0x2d] | (0x2 * (buffer[0x2c] | (0x2 * (buffer[0x2b] | (0x2 * (buffer[0x2f] | (0x2 * buffer[0x2a])))))))))];

        let destinationArray = Buffer.alloc(0x20);
        let d6 = 0x0;
        while (d6 < 0x8) {
          let bytes = Buffer.allocUnsafe(4);
          bytes.writeUInt32LE(numArray[d6], 0);
          bytes.copy(destinationArray, d6 * 4);
          d6++;
        }
        let d4 = 0x0;
        if (d2 <= 0x0) {
          let d7 = 0x20;
          do {
            in_buffer[d4] = (in_buffer[d4] ^ destinationArray[secret3[d4] - 0x1]);
            d4++;
            d7--;
          }
          while (d7 > 0x0);
        } else {
          let d8 = 0x20;
          do {
            let d9 = in_buffer[d4 + 0x20];
            let d10 = (in_buffer[d4] ^ destinationArray[secret3[d4] - 0x1]);
            d4++;
            d8--;
            in_buffer[d4 + 0x1f] = d10;
            in_buffer[d4 - 0x1] = d9;
          }
          while (d8 > 0x0);
        }
        d2--;
        if (d2 < 0) return;
      }
    } while (l2);
  }
}