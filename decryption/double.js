let secret1 = [
  0xbb1c, 0xea1f, 0xf0c1, 0x1feb, 0x2409, 0x79e1, 0xf578, 0xba6f, 0xe32c,
  0x2e7f, 0x76f0, 0x9703, 0xe1d6, 0x4036, 0xf2bf, 0x1b13, 0x75fd, 0xda9, 0xd5ad,
  0x935e, 0xc6f2, 0x7e65, 0x7ac5, 0x1853, 0xcd3c, 0x9e2, 0x7e31, 0x3ac4, 0xb3fe,
  0x2979, 0x86b7, 0x982f, 0x9f66, 0xf369, 0xdc9d, 0xa01b, 0xccfb, 0x41cc,
  0x6da6, 0x79f5, 0xb5b3, 0xa1d4, 0x4eda, 0x4f73, 0xcb42, 0x70ae, 0xcfbf,
  0x6295,
];

let secretGetBinary = (p) => (secret1[(p / 16) >>> 0] >>> p % 16) & 0x1;

let secret2 = [
  0x20, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15,
  0x10, 0x11, 0x10, 0x11, 0x12, 0x13, 20, 0x15, 20, 0x15, 0x16, 0x17, 0x18,
  0x19, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1c, 0x1d, 30, 0x1f, 0x20, 1,
];

let secret3 = [
  0x10, 7, 20, 0x15, 0x1d, 12, 0x1c, 0x11, 1, 15, 0x17, 0x1a, 5, 0x12, 0x1f, 10,
  2, 8, 0x18, 14, 0x20, 0x1b, 3, 9, 0x13, 13, 30, 6, 0x16, 11, 4, 0x19,
];

let secretArrays = [
  [
    0x10101, 0x100, 0x1000101, 0x1000000, 0x10000, 0x1010101, 0x1010001, 0x1,
    0x1010000, 0x10001, 0x10100, 0x101, 0x1000100, 0x1000001, 0x0, 0x1010100,
    0x0, 0x1010101, 0x1010100, 0x100, 0x10101, 0x10000, 0x1000101, 0x1000000,
    0x10001, 0x10100, 0x101, 0x1010001, 0x1000001, 0x1000100, 0x1010000, 0x1,
    0x100, 0x1000000, 0x10101, 0x1, 0x1000101, 0x10100, 0x10000, 0x1010001,
    0x1010101, 0x101, 0x1000001, 0x1010100, 0x1010000, 0x10001, 0x1000100, 0x0,
    0x1010101, 0x101, 0x1, 0x10000, 0x100, 0x1000001, 0x1000000, 0x1010100,
    0x1000100, 0x1010001, 0x1010000, 0x10101, 0x10001, 0x0, 0x10100, 0x1000101,
  ],
  [
    0x1010101, 0x1000000, 0x1, 0x10101, 0x10100, 0x1010001, 0x1010000, 0x100,
    0x1000001, 0x1010100, 0x10000, 0x1000101, 0x101, 0x0, 0x1000100, 0x10001,
    0x1010000, 0x1000101, 0x100, 0x1010100, 0x1010101, 0x10000, 0x1, 0x10101,
    0x101, 0x0, 0x1000000, 0x10001, 0x10100, 0x1000001, 0x1010001, 0x1000100,
    0x0, 0x10101, 0x1010100, 0x1010001, 0x10001, 0x100, 0x1000101, 0x1000000,
    0x1000100, 0x1, 0x101, 0x10100, 0x1000001, 0x1010000, 0x10000, 0x1010101,
    0x1000101, 0x1, 0x10001, 0x1000000, 0x1010000, 0x1010101, 0x100, 0x10000,
    0x1010001, 0x10100, 0x1010100, 0x101, 0x0, 0x1000100, 0x10101, 0x1000001,
  ],
  [
    0x10001, 0x0, 0x1000001, 0x10101, 0x10100, 0x1010000, 0x1010101, 0x1000100,
    0x1000000, 0x1000101, 0x101, 0x1010100, 0x1010001, 0x100, 0x10000, 0x1,
    0x1000101, 0x1010100, 0x0, 0x1000001, 0x1010000, 0x100, 0x10100, 0x10001,
    0x10000, 0x1, 0x1000100, 0x10101, 0x101, 0x1010001, 0x1010101, 0x1000000,
    0x1000101, 0x10100, 0x100, 0x1000001, 0x1, 0x1010101, 0x1010000, 0x0,
    0x1010001, 0x1000000, 0x10000, 0x101, 0x1000100, 0x10001, 0x10101,
    0x1010100, 0x1000000, 0x10001, 0x1000101, 0x0, 0x10100, 0x1000001, 0x1,
    0x1010100, 0x100, 0x1010101, 0x10101, 0x1010000, 0x1010001, 0x1000100,
    0x10000, 0x101,
  ],
  [
    0x1010100, 0x1000101, 0x10101, 0x1010000, 0x0, 0x10100, 0x1000001, 0x10001,
    0x1000000, 0x10000, 0x1, 0x1000100, 0x1010001, 0x101, 0x100, 0x1010101,
    0x1000101, 0x1, 0x1010001, 0x1000100, 0x10100, 0x1010101, 0x0, 0x1010000,
    0x100, 0x1010100, 0x10000, 0x101, 0x1000000, 0x10001, 0x10101, 0x1000001,
    0x10001, 0x10100, 0x1000001, 0x0, 0x101, 0x1010001, 0x1010100, 0x1000101,
    0x1010101, 0x1000000, 0x1010000, 0x10101, 0x1000100, 0x10000, 0x1, 0x100,
    0x1010000, 0x1010101, 0x0, 0x10100, 0x10001, 0x1000000, 0x1000101, 0x1,
    0x1000001, 0x100, 0x1000100, 0x1010001, 0x101, 0x1010100, 0x10000, 0x10101,
  ],
  [
    0x10000, 0x101, 0x100, 0x1000000, 0x1010100, 0x10001, 0x1010001, 0x10100,
    0x1, 0x1000100, 0x1010000, 0x1010101, 0x1000101, 0x0, 0x10101, 0x1000001,
    0x10101, 0x1010001, 0x10000, 0x101, 0x100, 0x1010100, 0x1000101, 0x1000000,
    0x1000100, 0x0, 0x1010101, 0x10001, 0x1010000, 0x1000001, 0x1, 0x10100,
    0x100, 0x10000, 0x1000000, 0x1010001, 0x10001, 0x1000101, 0x1010100, 0x1,
    0x1010101, 0x1000001, 0x101, 0x1000100, 0x10100, 0x1010000, 0x0, 0x10101,
    0x1010001, 0x1, 0x101, 0x1010100, 0x1000000, 0x10101, 0x10000, 0x1000101,
    0x10100, 0x1010101, 0x0, 0x1000001, 0x10001, 0x100, 0x1000100, 0x1010000,
  ],
  [
    0x101, 0x1000000, 0x10001, 0x1010101, 0x1000001, 0x10000, 0x10100, 0x1, 0x0,
    0x1000101, 0x1010000, 0x100, 0x10101, 0x1010100, 0x1000100, 0x1010001,
    0x10001, 0x1010101, 0x100, 0x10000, 0x1010100, 0x101, 0x1000001, 0x1000100,
    0x10100, 0x1000000, 0x1000101, 0x10101, 0x0, 0x1010001, 0x1010000, 0x1,
    0x1000001, 0x10101, 0x1010101, 0x1000100, 0x10000, 0x1, 0x101, 0x1010000,
    0x1010100, 0x0, 0x100, 0x10001, 0x1000000, 0x1000101, 0x1010001, 0x10100,
    0x100, 0x1010000, 0x10000, 0x101, 0x1000001, 0x1000100, 0x1010101, 0x10001,
    0x1010001, 0x10101, 0x1000000, 0x1010100, 0x10100, 0x0, 0x1, 0x1000101,
  ],
  [
    0x100, 0x1010001, 0x10000, 0x10101, 0x1010101, 0x0, 0x1, 0x1000101,
    0x1010000, 0x101, 0x1000001, 0x1010100, 0x1000100, 0x10001, 0x10100,
    0x1000000, 0x1000101, 0x0, 0x1010001, 0x1010100, 0x100, 0x1000001,
    0x1000000, 0x10001, 0x10101, 0x1010000, 0x1000100, 0x101, 0x10000,
    0x1010101, 0x1, 0x10100, 0x1000000, 0x100, 0x1010001, 0x1000101, 0x101,
    0x1010000, 0x1010100, 0x10101, 0x10001, 0x1010101, 0x10100, 0x1, 0x0,
    0x1000100, 0x1000001, 0x10000, 0x10100, 0x1010001, 0x1000101, 0x1,
    0x1000000, 0x100, 0x10001, 0x1010100, 0x1000001, 0x1000100, 0x0, 0x1010101,
    0x10101, 0x10000, 0x1010000, 0x101,
  ],
  [
    0x1000101, 0x10000, 0x1, 0x100, 0x10100, 0x1010101, 0x1010001, 0x1000000,
    0x10001, 0x1000001, 0x1010000, 0x10101, 0x1000100, 0x0, 0x101, 0x1010100,
    0x1000000, 0x1010101, 0x1000101, 0x1, 0x10001, 0x1010000, 0x1010100, 0x100,
    0x101, 0x1000100, 0x10100, 0x1010001, 0x0, 0x10101, 0x1000001, 0x10000,
    0x1010100, 0x1010001, 0x100, 0x1000000, 0x1000001, 0x101, 0x10101, 0x10000,
    0x0, 0x10100, 0x10001, 0x1000101, 0x1010101, 0x1010000, 0x1000100, 0x1,
    0x10000, 0x1000000, 0x10101, 0x1010100, 0x100, 0x10001, 0x1, 0x1000101,
    0x1010101, 0x101, 0x1000001, 0x0, 0x1010000, 0x1000100, 0x10100, 0x1010001,
  ],
];

exports.decode = (buffer, x1, x2, x3) => {
  // first encryption
  let out_buffer = bit_encryption(buffer);

  // second encryption
  let key1 = x1 | 0x0418;
  let key2 = x2 | 0x8041;
  let key3 = x3 | 0x1804;

  for (let i = 0; i < out_buffer.length; i++) {
    let data = out_buffer[i];
    let out = data ^ (key1 >> 8);
    key1 = ((data + key1) * key2 + key3) & 0xffff;
    out_buffer[i] = out;
  }

  return out_buffer;
};

exports.determine = () => {
  return false; // disabled for now, something doesn't work right! :(
};

function bit_encryption(buffer) {
  let num = (buffer.length - 20 + 7) >> 3;
  let num2 = 0;
  let num3 = 0;

  let tBuffer = Buffer.allocUnsafe(0x40);
  let buffer2 = buffer.slice(20);

  // eslint-disable-next-line no-constant-condition
  while (true) {
    tBuffer.fill(0);
    let d2 = 0;
    let d3 = 8;

    do {
      let num4 = buffer2[num2++];
      tBuffer[d2] = (num4 >> 7) & 1;
      let index = d2 + 1;
      tBuffer[index++] = (num4 >> 6) & 1;
      tBuffer[index++] = (num4 >> 5) & 1;
      tBuffer[index++] = (num4 >> 4) & 1;
      tBuffer[index++] = (num4 >> 3) & 1;
      tBuffer[index++] = (num4 >> 2) & 1;
      tBuffer[index++] = (num4 >> 1) & 1;
      tBuffer[index] = num4 & 1;
      d2 = index + 1;
      d3--;
    } while (d3 > 0);

    // now we have 64 bit data spreaded each bit as byte in tBuffer
    sub_step(tBuffer);

    // now we should make 64 bit data to 8 byte back
    let d4 = 0;
    let d5;
    do {
      d5 =
        tBuffer[d4 + 7] |
        (2 *
          (tBuffer[d4 + 6] |
            (2 *
              (tBuffer[d4 + 5] |
                (2 *
                  (tBuffer[d4 + 4] |
                    (2 *
                      (tBuffer[d4 + 3] |
                        (2 *
                          (tBuffer[d4 + 2] |
                            (2 *
                              (tBuffer[d4 + 1] | (2 * tBuffer[d4])))))))))))));
      d4 += 8;
      buffer2[num3++] = d5;
    } while (d4 < 0x40);
    if (num-- == 1) {
      break;
    }
  }

  return buffer2.slice(
    0,
    (buffer[16] << 0x18) +
      (buffer[17] << 0x10) +
      (buffer[18] << 0x8) +
      buffer[19]
  );
}

function sub_step(in_buffer) {
  let d2 = 0xf;
  let numArray = [];
  let buffer = Buffer.alloc(0x30);

  // eslint-disable-next-line no-constant-condition
  while (true) {
    let d3 = 0x0;
    let l2 = true;

    do {
      let t = secretGetBinary(0x30 * d2 + d3) ^ in_buffer[secret2[d3] + 0x1f];
      d3++;
      buffer[d3 - 0x1] = t;
      if (d3 >= 0x30) {
        l2 = false;

        numArray[0x0] =
          secretArrays[0][
            buffer[0x4] |
              (0x2 *
                (buffer[0x3] |
                  (0x2 *
                    (buffer[0x2] |
                      (0x2 *
                        (buffer[0x1] |
                          (0x2 * (buffer[0x5] | (0x2 * buffer[0x0])))))))))
          ];
        numArray[0x1] =
          secretArrays[1][
            buffer[0xa] |
              (0x2 *
                (buffer[0x9] |
                  (0x2 *
                    (buffer[0x8] |
                      (0x2 *
                        (buffer[0x7] |
                          (0x2 * (buffer[0xb] | (0x2 * buffer[0x6])))))))))
          ];
        numArray[0x2] =
          secretArrays[2][
            buffer[0x10] |
              (0x2 *
                (buffer[0xf] |
                  (0x2 *
                    (buffer[0xe] |
                      (0x2 *
                        (buffer[0xd] |
                          (0x2 * (buffer[0x11] | (0x2 * buffer[0xc])))))))))
          ];
        numArray[0x3] =
          secretArrays[3][
            buffer[0x16] |
              (0x2 *
                (buffer[0x15] |
                  (0x2 *
                    (buffer[0x14] |
                      (0x2 *
                        (buffer[0x13] |
                          (0x2 * (buffer[0x17] | (0x2 * buffer[0x12])))))))))
          ];
        numArray[0x4] =
          secretArrays[4][
            buffer[0x1c] |
              (0x2 *
                (buffer[0x1b] |
                  (0x2 *
                    (buffer[0x1a] |
                      (0x2 *
                        (buffer[0x19] |
                          (0x2 * (buffer[0x1d] | (0x2 * buffer[0x18])))))))))
          ];
        numArray[0x5] =
          secretArrays[5][
            buffer[0x22] |
              (0x2 *
                (buffer[0x21] |
                  (0x2 *
                    (buffer[0x20] |
                      (0x2 *
                        (buffer[0x1f] |
                          (0x2 * (buffer[0x23] | (0x2 * buffer[0x1e])))))))))
          ];
        numArray[0x6] =
          secretArrays[6][
            buffer[0x28] |
              (0x2 *
                (buffer[0x27] |
                  (0x2 *
                    (buffer[0x26] |
                      (0x2 *
                        (buffer[0x25] |
                          (0x2 * (buffer[0x29] | (0x2 * buffer[0x24])))))))))
          ];
        numArray[0x7] =
          secretArrays[7][
            buffer[0x2e] |
              (0x2 *
                (buffer[0x2d] |
                  (0x2 *
                    (buffer[0x2c] |
                      (0x2 *
                        (buffer[0x2b] |
                          (0x2 * (buffer[0x2f] | (0x2 * buffer[0x2a])))))))))
          ];

        let destinationArray = Buffer.alloc(0x20);
        let d6 = 0x0;
        while (d6 < 0x8) {
          let bytes = Buffer.allocUnsafe(4);
          bytes.writeUInt32LE(numArray[d6], 0);
          bytes.copy(destinationArray, d6 * 4);
          d6++;
        }
        let d4 = 0x0;
        if (d2 <= 0x0) {
          let d7 = 0x20;
          do {
            in_buffer[d4] = in_buffer[d4] ^ destinationArray[secret3[d4] - 0x1];
            d4++;
            d7--;
          } while (d7 > 0x0);
        } else {
          let d8 = 0x20;
          do {
            let d9 = in_buffer[d4 + 0x20];
            let d10 = in_buffer[d4] ^ destinationArray[secret3[d4] - 0x1];
            d4++;
            d8--;
            in_buffer[d4 + 0x1f] = d10;
            in_buffer[d4 - 0x1] = d9;
          } while (d8 > 0x0);
        }
        d2--;
        if (d2 < 0) return;
      }
    } while (l2);
  }
}
